# 01 架构是什么?
[参考](https://time.geekbang.org/column/article/6458)
## 概念梳理
### 系统与子系统
#### 系统
* 关联: 系统是由有关联的个体组成
* 规则: 系统内的个体需要以一定的规则一起动作
* 能力: 系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力

#### 模块与组件
*都是系统的组成部分，只是从不同的角度对系统进行拆分*
* 模块: 从逻辑角度进行拆分，如登录注册模块、个人信息模块、个人成绩模块等
* 组件: 从物理(功能)角度进行拆分，如nginx、Web服务器、Mysql等

#### 框架与架构
* 框架：组件规范，如MVC、MVP、J2EE等；框架提供基础功能的产品，如Spring MVC除了满足MVC规范外，还提供了Spring Secruity、Spring JPA等很多基础功能。
* 架构：软件基础结构。软件系统的顶层结构

# 02 架构设计的历史背景
[参考](https://time.geekbang.org/column/article/6463)
## 机器语言(二进制): 1940年前
* 太难写
## 汇编语言：20世纪40年代
* 还是难写
* 各厂商不一致
## 高级语言：20世纪50年代
## 第一次软件危机与结构化程序设计（20 世纪 60 年代~20世纪 70 年代）
* 结构化程序设计方法
## 第二次软件危机与面向对象（20 世纪 80 年代）
* 面向对象程序设计方法

# 03 架构设计的目的
[参考](https://time.geekbang.org/column/article/6472)
## 误区
* 因为架构重要，所以要设计
* 每个系统都要做架构设计
* 公司流程要求
* 为了高性能、高可用、可扩展
## 真正目的
*架构设计的主要目的是为了解决软件系统**复杂度**带来的问题。*
- 心中有数
- 有的放矢，不可贪大求全

# 04 复杂度来源：高性能
[参考](https://time.geekbang.org/column/article/6605)
软件系统中高性能带来的复杂度主要体现在两方面:
* 单台计算机内部为了高性能带来的复杂度
* 多台计算机集群为了高性能带来的复杂度

## 单机复杂度
## 集群复杂度
* 任务分配
* 任务分解
	- 简单的系统更容易做到高性能
	- 可以针对单个任务进行扩展
*任务分解带来的性能收益是有一个度的，并不是任务分解越细越好，而对于架构设计来说，如何把握这个粒度就非常关键了*
## 问题
* 为什么要高性能
追求良好的用户体验；
满足业务增长的需要。
* 如何做好高性能？
	- 垂直维度
		+ 增大内存减少I/O操作
		+ 更换为固态硬盘（SSD）提升I/O访问速度
		+ 使用RAID增加I/O吞吐能力
		+ 置换服务器获得更多的处理器或分配更多的虚拟核
		+ 升级网络接口或增加网络接口
	- 水平维度
		+ 功能分解：基于功能将系统分解为更小的子系统
		+ 多实例副本：同一组件重复部署到多台不同的服务器
		+ 数据分割：在每台机器上都只部署一部分数据

# 05 复杂度来源：高可用
[参考](https://time.geekbang.org/column/article/6895)
*系统的高可用方案五花八门，但万变不离其宗，本质上都是通过“冗余”来实现高可用*
## 与高性能同样增加更多机器来达到目的，但有本质不同
* 高性能增加机器目的在于“扩展”处理性能
* 高可用增加机器目的在于“冗余”处理单元

## 高可用分类
### 计算高可用
*计算的特点:无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都一样*
### 存储高可用
*存储与计算相比，有一个本质上的区别：将数据从一台机器搬到到另一台机器，需要经过线路进行传输*
*存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响*

#### 分布式领域 CAP 理论
* 存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足两个

## 高可用状态决策
*通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确*
- 独裁式
- 协商式
	+ 常用的协商式决策为主备决策
- 民主式
	+ ZooKeeper(Paxos)
	+ etcd (raft)

# 06 复杂度来源：可扩展性
[参考](https://time.geekbang.org/column/article/6899)
